---
title: データ保護の ASP.NET Core
author: rick-anderson
description: データ保護の概念と、ASP.NET Core データ保護 Api の設計原則について説明します。
ms.author: riande
ms.custom: mvc
ms.date: 10/24/2018
no-loc:
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/introduction
ms.openlocfilehash: b29711e8e1ef1558731ba58ca2ff14000af19ca2
ms.sourcegitcommit: 497be502426e9d90bb7d0401b1b9f74b6a384682
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/08/2020
ms.locfileid: "88019357"
---
# <a name="aspnet-core-data-protection"></a><span data-ttu-id="fbde5-103">データ保護の ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="fbde5-103">ASP.NET Core Data Protection</span></span>

<span data-ttu-id="fbde5-104">多くの場合、Web アプリケーションは、セキュリティを重視するデータを格納する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-104">Web applications often need to store security-sensitive data.</span></span> <span data-ttu-id="fbde5-105">Windows では、デスクトップアプリケーション用に DPAPI が提供されていますが、これは web アプリケーションには適していません。</span><span class="sxs-lookup"><span data-stu-id="fbde5-105">Windows provides DPAPI for desktop applications but this is unsuitable for web applications.</span></span> <span data-ttu-id="fbde5-106">ASP.NET Core データ保護スタックは、開発者がキーの管理やローテーションなどのデータを保護するために使用できる、シンプルで使いやすい暗号化 API を提供します。</span><span class="sxs-lookup"><span data-stu-id="fbde5-106">The ASP.NET Core data protection stack provide a simple, easy to use cryptographic API a developer can use to protect data, including key management and rotation.</span></span>

<span data-ttu-id="fbde5-107">ASP.NET Core データ保護スタックは、 &lt; &gt; ASP.NET 1.x-4.X の machineKey 要素の長期的な置換として機能するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-107">The ASP.NET Core data protection stack is designed to serve as the long-term replacement for the &lt;machineKey&gt; element in ASP.NET 1.x - 4.x.</span></span> <span data-ttu-id="fbde5-108">これは、古い暗号化スタックの多くの欠点に対処するように設計されており、最新のアプリケーションが発生する可能性のあるほとんどのユースケースに対して、すぐに使用できるソリューションを提供しています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-108">It was designed to address many of the shortcomings of the old cryptographic stack while providing an out-of-the-box solution for the majority of use cases modern applications are likely to encounter.</span></span>

## <a name="problem-statement"></a><span data-ttu-id="fbde5-109">問題の説明</span><span class="sxs-lookup"><span data-stu-id="fbde5-109">Problem statement</span></span>

<span data-ttu-id="fbde5-110">全体的な問題の説明は、1つの文で簡潔に記述できます。後で取得するために信頼できる情報を保持する必要がありますが、永続化メカニズムを信頼していません。</span><span class="sxs-lookup"><span data-stu-id="fbde5-110">The overall problem statement can be succinctly stated in a single sentence: I need to persist trusted information for later retrieval, but I don't trust the persistence mechanism.</span></span> <span data-ttu-id="fbde5-111">Web 用語では、"信頼された状態を信頼されていないクライアント経由でラウンドトリップする必要がある" として記述されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-111">In web terms, this might be written as "I need to round-trip trusted state via an untrusted client."</span></span>

<span data-ttu-id="fbde5-112">この例では、認証またはベアラートークンが使用されてい cookie ます。</span><span class="sxs-lookup"><span data-stu-id="fbde5-112">The canonical example of this is an authentication cookie or bearer token.</span></span> <span data-ttu-id="fbde5-113">サーバーは "I am Groot と" xyz アクセス許可 "トークンを生成し、クライアントに渡します。</span><span class="sxs-lookup"><span data-stu-id="fbde5-113">The server generates an "I am Groot and have xyz permissions" token and hands it to the client.</span></span> <span data-ttu-id="fbde5-114">将来の日付では、クライアントはそのトークンをサーバーに返しますが、サーバーでは、クライアントがトークンを偽造していないことを保証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-114">At some future date the client will present that token back to the server, but the server needs some kind of assurance that the client hasn't forged the token.</span></span> <span data-ttu-id="fbde5-115">そのため、最初の要件: 信頼性 (</span><span class="sxs-lookup"><span data-stu-id="fbde5-115">Thus the first requirement: authenticity (a.k.a.</span></span> <span data-ttu-id="fbde5-116">整合性、改ざん防止)。</span><span class="sxs-lookup"><span data-stu-id="fbde5-116">integrity, tamper-proofing).</span></span>

<span data-ttu-id="fbde5-117">永続化された状態はサーバーによって信頼されているため、この状態には、オペレーティング環境に固有の情報が含まれている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-117">Since the persisted state is trusted by the server, we anticipate that this state might contain information that's specific to the operating environment.</span></span> <span data-ttu-id="fbde5-118">ファイルパス、アクセス許可、ハンドルまたはその他の間接参照、またはサーバー固有のその他のデータの形式を使用できます。</span><span class="sxs-lookup"><span data-stu-id="fbde5-118">This could be in the form of a file path, a permission, a handle or other indirect reference, or some other piece of server-specific data.</span></span> <span data-ttu-id="fbde5-119">通常、このような情報は、信頼されていないクライアントに公開することはできません。</span><span class="sxs-lookup"><span data-stu-id="fbde5-119">Such information should generally not be disclosed to an untrusted client.</span></span> <span data-ttu-id="fbde5-120">そのため、2番目の要件は機密性です。</span><span class="sxs-lookup"><span data-stu-id="fbde5-120">Thus the second requirement: confidentiality.</span></span>

<span data-ttu-id="fbde5-121">最後に、最新のアプリケーションがコンポーネント化されているため、システム内の他のコンポーネントに関係なく、個々のコンポーネントでこのシステムを利用することが求められています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-121">Finally, since modern applications are componentized, what we've seen is that individual components will want to take advantage of this system without regard to other components in the system.</span></span> <span data-ttu-id="fbde5-122">たとえば、ベアラートークンコンポーネントがこのスタックを使用している場合は、同じスタックを使用している可能性のある CSRF メカニズムからの干渉なしで動作する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-122">For instance, if a bearer token component is using this stack, it should operate without interference from an anti-CSRF mechanism that might also be using the same stack.</span></span> <span data-ttu-id="fbde5-123">そのため、最終的な要件は分離です。</span><span class="sxs-lookup"><span data-stu-id="fbde5-123">Thus the final requirement: isolation.</span></span>

<span data-ttu-id="fbde5-124">要件の範囲を絞るために、さらに制約を与えることができます。</span><span class="sxs-lookup"><span data-stu-id="fbde5-124">We can provide further constraints in order to narrow the scope of our requirements.</span></span> <span data-ttu-id="fbde5-125">ここでは、cryptosystem 内で動作するすべてのサービスが同じように信頼されており、直接制御しているサービスの外部でデータを生成または使用する必要がないことを想定しています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-125">We assume that all services operating within the cryptosystem are equally trusted and that the data doesn't need to be generated or consumed outside of the services under our direct control.</span></span> <span data-ttu-id="fbde5-126">さらに、web サービスに対する各要求が cryptosystem を1回以上通過する可能性があるため、可能な限り高速操作を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-126">Furthermore, we require that operations are as fast as possible since each request to the web service might go through the cryptosystem one or more times.</span></span> <span data-ttu-id="fbde5-127">これにより、対称暗号化がシナリオに適したものになるため、必要な時間まで非対称暗号化を割引できます。</span><span class="sxs-lookup"><span data-stu-id="fbde5-127">This makes symmetric cryptography ideal for our scenario, and we can discount asymmetric cryptography until such a time that it's needed.</span></span>

## <a name="design-philosophy"></a><span data-ttu-id="fbde5-128">設計思想</span><span class="sxs-lookup"><span data-stu-id="fbde5-128">Design philosophy</span></span>

<span data-ttu-id="fbde5-129">まず、既存のスタックに関する問題を特定しました。</span><span class="sxs-lookup"><span data-stu-id="fbde5-129">We started by identifying problems with the existing stack.</span></span> <span data-ttu-id="fbde5-130">これを行った後は、既存のソリューションのランドスケープを調査し、既存のソリューションには、お探しの機能がまったくないという結論を与えました。</span><span class="sxs-lookup"><span data-stu-id="fbde5-130">Once we had that, we surveyed the landscape of existing solutions and concluded that no existing solution quite had the capabilities we sought.</span></span> <span data-ttu-id="fbde5-131">次に、いくつかの基本原則に基づいてソリューションを設計しています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-131">We then engineered a solution based on several guiding principles.</span></span>

* <span data-ttu-id="fbde5-132">システムは、構成を簡単にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-132">The system should offer simplicity of configuration.</span></span> <span data-ttu-id="fbde5-133">理想的には、システムがゼロ構成であり、開発者が実行を開始する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-133">Ideally the system would be zero-configuration and developers could hit the ground running.</span></span> <span data-ttu-id="fbde5-134">開発者が特定の側面 (キーリポジトリなど) を構成する必要がある場合は、これらの特定の構成を単純にすることを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-134">In situations where developers need to configure a specific aspect (such as the key repository), consideration should be given to making those specific configurations simple.</span></span>

* <span data-ttu-id="fbde5-135">コンシューマー向けのシンプルな API を提供します。</span><span class="sxs-lookup"><span data-stu-id="fbde5-135">Offer a simple consumer-facing API.</span></span> <span data-ttu-id="fbde5-136">Api は、正しく使用するのが簡単で、不適切に使用するのは困難です。</span><span class="sxs-lookup"><span data-stu-id="fbde5-136">The APIs should be easy to use correctly and difficult to use incorrectly.</span></span>

* <span data-ttu-id="fbde5-137">開発者は、キー管理の原則を習得するべきではありません。</span><span class="sxs-lookup"><span data-stu-id="fbde5-137">Developers shouldn't learn key management principles.</span></span> <span data-ttu-id="fbde5-138">システムは、開発者の代わりに、アルゴリズムの選択とキーの有効期間を処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-138">The system should handle algorithm selection and key lifetime on the developer's behalf.</span></span> <span data-ttu-id="fbde5-139">理想的には、開発者が未加工のキーマテリアルにアクセスできないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-139">Ideally the developer should never even have access to the raw key material.</span></span>

* <span data-ttu-id="fbde5-140">可能な場合は、保存時にキーを保護する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-140">Keys should be protected at rest when possible.</span></span> <span data-ttu-id="fbde5-141">システムは、適切な既定の保護メカニズムを見つけて、自動的に適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbde5-141">The system should figure out an appropriate default protection mechanism and apply it automatically.</span></span>

<span data-ttu-id="fbde5-142">これらの原則を念頭に置いて、シンプルで使い[やすい](xref:security/data-protection/using-data-protection)データ保護スタックを開発しました。</span><span class="sxs-lookup"><span data-stu-id="fbde5-142">With these principles in mind we developed a simple, [easy to use](xref:security/data-protection/using-data-protection) data protection stack.</span></span>

<span data-ttu-id="fbde5-143">ASP.NET Core データ保護 Api は、主に機密ペイロードの永続的な永続化のためのものではありません。</span><span class="sxs-lookup"><span data-stu-id="fbde5-143">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="fbde5-144">[WINDOWS CNG DPAPI](/windows/win32/seccng/cng-dpapi)や[Azure Rights Management](/rights-management/)などのその他のテクノロジは、無期限のストレージのシナリオに適しています。また、強力なキー管理機能も備えています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-144">Other technologies like [Windows CNG DPAPI](/windows/win32/seccng/cng-dpapi) and [Azure Rights Management](/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="fbde5-145">ただし、社外秘データの長期的な保護には、ASP.NET Core データ保護 Api を使用した開発者の禁止はありません。</span><span class="sxs-lookup"><span data-stu-id="fbde5-145">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span>

## <a name="audience"></a><span data-ttu-id="fbde5-146">対象ユーザー</span><span class="sxs-lookup"><span data-stu-id="fbde5-146">Audience</span></span>

<span data-ttu-id="fbde5-147">データ保護システムは、5つのメインパッケージに分割されています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-147">The data protection system is divided into five main packages.</span></span> <span data-ttu-id="fbde5-148">これらの Api のさまざまな側面は、3つの主要な対象ユーザーを対象とします。</span><span class="sxs-lookup"><span data-stu-id="fbde5-148">Various aspects of these APIs target three main audiences;</span></span>

1. <span data-ttu-id="fbde5-149">[コンシューマー api の概要](xref:security/data-protection/consumer-apis/overview)については、アプリケーションとフレームワークの開発者を対象としています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-149">The [Consumer APIs Overview](xref:security/data-protection/consumer-apis/overview) target application and framework developers.</span></span>

   <span data-ttu-id="fbde5-150">「スタックの動作方法や構成方法について知りたくありません。</span><span class="sxs-lookup"><span data-stu-id="fbde5-150">"I don't want to learn about how the stack operates or about how it's configured.</span></span> <span data-ttu-id="fbde5-151">単に、Api を正常に使用できる確率で、可能な限り単純な方法で操作を実行したいと考えています。」</span><span class="sxs-lookup"><span data-stu-id="fbde5-151">I simply want to perform some operation in as simple a manner as possible with high probability of using the APIs successfully."</span></span>

2. <span data-ttu-id="fbde5-152">[構成 api](xref:security/data-protection/configuration/overview)は、アプリケーション開発者とシステム管理者を対象としています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-152">The [configuration APIs](xref:security/data-protection/configuration/overview) target application developers and system administrators.</span></span>

   <span data-ttu-id="fbde5-153">「データ保護システムに、既定以外のパスや設定が必要であることを知らせる必要があります。」</span><span class="sxs-lookup"><span data-stu-id="fbde5-153">"I need to tell the data protection system that my environment requires non-default paths or settings."</span></span>

3. <span data-ttu-id="fbde5-154">拡張 Api は、カスタムポリシーの実装を担当する開発者を対象としています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-154">The extensibility APIs target developers in charge of implementing custom policy.</span></span> <span data-ttu-id="fbde5-155">これらの Api の使用は、まれな状況や経験豊富な開発者に限定されます。</span><span class="sxs-lookup"><span data-stu-id="fbde5-155">Usage of these APIs would be limited to rare situations and experienced, security aware developers.</span></span>

   <span data-ttu-id="fbde5-156">「システム内のコンポーネント全体を置き換える必要があります。これは、本当に独特な行動要件があるためです。</span><span class="sxs-lookup"><span data-stu-id="fbde5-156">"I need to replace an entire component within the system because I have truly unique behavioral requirements.</span></span> <span data-ttu-id="fbde5-157">要件を満たすプラグインを構築するために、API サーフェイスの一般的に使用されない部分について学習します。</span><span class="sxs-lookup"><span data-stu-id="fbde5-157">I am willing to learn uncommonly-used parts of the API surface in order to build a plugin that fulfills my requirements."</span></span>

## <a name="package-layout"></a><span data-ttu-id="fbde5-158">パッケージのレイアウト</span><span class="sxs-lookup"><span data-stu-id="fbde5-158">Package layout</span></span>

<span data-ttu-id="fbde5-159">データ保護スタックは、5つのパッケージで構成されます。</span><span class="sxs-lookup"><span data-stu-id="fbde5-159">The data protection stack consists of five packages.</span></span>

* <span data-ttu-id="fbde5-160">[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/)には、 <xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider> <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> データ保護サービスを作成するためのインターフェイスとインターフェイスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-160">[Microsoft.AspNetCore.DataProtection.Abstractions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/) contains the <xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider> and <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> interfaces to create data protection services.</span></span> <span data-ttu-id="fbde5-161">また、これらの型を操作するための便利な拡張メソッドも含まれています (たとえば、 [IDataProtector](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*))。</span><span class="sxs-lookup"><span data-stu-id="fbde5-161">It also contains useful extension methods for working with these types (for example, [IDataProtector.Protect](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*)).</span></span> <span data-ttu-id="fbde5-162">データ保護システムが他の場所でインスタンス化されており、API を使用している場合は、「」を参照 `Microsoft.AspNetCore.DataProtection.Abstractions` してください。</span><span class="sxs-lookup"><span data-stu-id="fbde5-162">If the data protection system is instantiated elsewhere and you're consuming the API, reference `Microsoft.AspNetCore.DataProtection.Abstractions`.</span></span>

* <span data-ttu-id="fbde5-163">[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/)には、データ保護システムのコア実装が含まれています。これには、主要な暗号化操作、キー管理、構成、および拡張機能が含まれます。</span><span class="sxs-lookup"><span data-stu-id="fbde5-163">[Microsoft.AspNetCore.DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/) contains the core implementation of the data protection system, including core cryptographic operations, key management, configuration, and extensibility.</span></span> <span data-ttu-id="fbde5-164">データ保護システムをインスタンス化する (たとえば、に追加する <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection> )、その動作を変更または拡張するには、「」を参照 `Microsoft.AspNetCore.DataProtection` してください。</span><span class="sxs-lookup"><span data-stu-id="fbde5-164">To instantiate the data protection system (for example, adding it to an <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection>) or modifying or extending its behavior, reference `Microsoft.AspNetCore.DataProtection`.</span></span>

* <span data-ttu-id="fbde5-165">[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/)には、開発者が役に立つがコアパッケージに属さない追加の api が含まれています。</span><span class="sxs-lookup"><span data-stu-id="fbde5-165">[Microsoft.AspNetCore.DataProtection.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/) contains additional APIs which developers might find useful but which don't belong in the core package.</span></span> <span data-ttu-id="fbde5-166">たとえば、このパッケージには、データ保護システムをインスタンス化して、依存関係を挿入せずにファイルシステム上の場所にキーを格納するファクトリメソッドが含まれています (「」を参照してください <xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider> )。</span><span class="sxs-lookup"><span data-stu-id="fbde5-166">For instance, this package contains factory methods to instantiate the data protection system to store keys at a location on the file system without dependency injection (see <xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider>).</span></span> <span data-ttu-id="fbde5-167">また、保護されたペイロードの有効期間を制限するための拡張メソッドも含まれています (を参照してください <xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector> )。</span><span class="sxs-lookup"><span data-stu-id="fbde5-167">It also contains extension methods for limiting the lifetime of protected payloads (see <xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector>).</span></span>

* <span data-ttu-id="fbde5-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/)を既存の ASP.NET 4.x アプリにインストールして、 `<machineKey>` 新しい ASP.NET Core データ保護スタックを使用するように操作をリダイレクトすることができます。</span><span class="sxs-lookup"><span data-stu-id="fbde5-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/) can be installed into an existing ASP.NET 4.x app to redirect its `<machineKey>` operations to use the new ASP.NET Core data protection stack.</span></span> <span data-ttu-id="fbde5-169">詳細については、「<xref:security/data-protection/compatibility/replacing-machinekey>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fbde5-169">For more information, see <xref:security/data-protection/compatibility/replacing-machinekey>.</span></span>

* <span data-ttu-id="fbde5-170">[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/)は、PBKDF2 パスワードハッシュルーチンの実装を提供し、ユーザーパスワードを安全に処理する必要があるシステムで使用できます。</span><span class="sxs-lookup"><span data-stu-id="fbde5-170">[Microsoft.AspNetCore.Cryptography.KeyDerivation](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/) provides an implementation of the PBKDF2 password hashing routine and can be used by systems that must handle user passwords securely.</span></span> <span data-ttu-id="fbde5-171">詳細については、「<xref:security/data-protection/consumer-apis/password-hashing>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fbde5-171">For more information, see <xref:security/data-protection/consumer-apis/password-hashing>.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="fbde5-172">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="fbde5-172">Additional resources</span></span>

<xref:host-and-deploy/web-farm>
